@thesis{Castagna_2016,
  doi       = {10.1145/2951913.2951928},
  url       = {https://doi.org/10.1145%2F2951913.2951928},
  year      = 2016,
  month     = 9,
  publisher = {{ACM}},
  author    = {Giuseppe Castagna and Tommaso Petrucciani and Kim Nguyen},
  title     = {Set-theoretic types for polymorphic variants},
  booktitle = {Proceedings of the 21st {ACM} {SIGPLAN} International Conference on Functional Programming}
}
@thesis{Garrigue_1998,
  title     = {Programming with Polymorphic Variants},
  author    = {Jacques Garrigue},
  year      = {1998},
  publisher = {{ACM SIGPLAN Workshop on ML}},
  url       = {https://caml.inria.fr/pub/papers/garrigue-polymorphic_variants-ml98.pdf}
}

@thesis{setvariants,
  title = {setvariants},
  url   = {https://gitlab.math.univ-paris-diderot.fr/petrucciani/setvariants},
  note  = {Implementations of the set-theoretic types for the subset of the OCaml language.
           Available online: \url{https://www.cduce.org/ocaml/}, \url{https://www.cduce.org/ocaml/bi}}
}

@thesis{Hindley_1969,
  issn      = {00029947},
  url       = {http://www.jstor.org/stable/1995158},
  author    = {R. Hindley},
  journal   = {Transactions of the American Mathematical Society},
  pages     = {29--60},
  publisher = {American Mathematical Society},
  title     = {The Principal Type-Scheme of an Object in Combinatory Logic},
  volume    = {146},
  year      = {1969}
}

@thesis{Milner_1978,
  title   = {A theory of type polymorphism in programming},
  journal = {Journal of Computer and System Sciences},
  volume  = {17},
  number  = {3},
  pages   = {348-375},
  year    = {1978},
  issn    = {0022-0000},
  doi     = {https://doi.org/10.1016/0022-0000(78)90014-4},
  url     = {https://www.sciencedirect.com/science/article/pii/0022000078900144},
  author  = {Robin Milner}
}

@thesis{Castagna_2015,
  author     = {Castagna, Giuseppe and Nguyen, Kim and Xu, Zhiwu and Abate, Pietro},
  title      = {Polymorphic Functions with Set-Theoretic Types: Part 2: Local Type Inference and Type Reconstruction},
  year       = {2015},
  issue_date = {January 2015},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {50},
  number     = {1},
  issn       = {0362-1340},
  url        = {https://doi.org/10.1145/2775051.2676991},
  doi        = {10.1145/2775051.2676991},
  abstract   = {This article is the second part of a two articles series about the definition of higher order polymorphic functions in a type system with recursive types and set-theoretic type connectives (unions, intersections, and negations).In the first part, presented in a companion paper, we defined and studied the syntax, semantics, and evaluation of the explicitly-typed version of a calculus, in which type instantiation is driven by explicit instantiation annotations. In this second part we present a local type inference system that allows the programmer to omit explicit instantiation annotations for function applications, and a type reconstruction system that allows the programmer to omit explicit type annotations for function definitions.The work presented in the two articles provides the theoretical foundations and technical machinery needed to design and implement higher-order polymorphic functional languages with union and intersection types and/or for semi-structured data processing.},
  journal    = {SIGPLAN Not.},
  month      = {1},
  pages      = {289-302},
  numpages   = {14},
  keywords   = {semantic subtyping, type constraints, intersection types, polymorphism, xml, types}
}
